--- a/net/minecraft/world/level/storage/DimensionDataStorage.java
+++ b/net/minecraft/world/level/storage/DimensionDataStorage.java
@@ -55,7 +_,7 @@
         if (savedData != null) {
             return savedData;
         } else {
-            T savedData1 = (T)factory.constructor().get();
+            T savedData1 = factory.constructor().get();
             this.set(name, savedData1);
             return savedData1;
         }
@@ -69,7 +_,7 @@
             this.cache.put(name, optional);
         }
 
-        return (T)optional.orElse(null);
+        return (T) optional.orElse(null);
     }
 
     @Nullable
@@ -137,12 +_,12 @@
         if (map.isEmpty()) {
             return CompletableFuture.completedFuture(null);
         } else {
-            int i = Util.maxAllowedExecutorThreads();
+            int maxAllowedExecutorThreads = Util.maxAllowedExecutorThreads();
             int size = map.size();
-            if (size > i) {
+            if (false && size > maxAllowedExecutorThreads) { // Paper - Separate dimension data IO pool; just throw them into the fixed pool queue
                 this.pendingWriteFuture = this.pendingWriteFuture.thenCompose(object -> {
-                    List<CompletableFuture<?>> list = new ArrayList<>(i);
-                    int i1 = Mth.positiveCeilDiv(size, i);
+                    List<CompletableFuture<?>> list = new ArrayList<>(maxAllowedExecutorThreads);
+                    int i1 = Mth.positiveCeilDiv(size, maxAllowedExecutorThreads);
 
                     for (List<Entry<Path, CompoundTag>> list1 : Iterables.partition(map.entrySet(), i1)) {
                         list.add(CompletableFuture.runAsync(() -> {
@@ -160,7 +_,7 @@
                         object -> CompletableFuture.allOf(
                             map.entrySet()
                                 .stream()
-                                .map(entry -> CompletableFuture.runAsync(() -> tryWrite(entry.getKey(), entry.getValue()), Util.ioPool()))
+                                .map(entry -> CompletableFuture.runAsync(() -> tryWrite(entry.getKey(), entry.getValue()), Util.DIMENSION_DATA_IO_POOL)) // Paper - Separate dimension data IO pool
                                 .toArray(CompletableFuture[]::new)
                         )
                     );
